// ======================================================================
// \title  DpDemo_StringArrayArrayAc.cpp
// \author Generated by fpp-to-cpp
// \brief  cpp file for DpDemo_StringArray array
// ======================================================================

#include "Fw/Types/Assert.hpp"
#include "Ref/DpDemo/DpDemo_StringArrayArrayAc.hpp"

namespace Ref {

  // ----------------------------------------------------------------------
  // Constructors
  // ----------------------------------------------------------------------

  DpDemo_StringArray ::
    DpDemo_StringArray() :
      Serializable()
  {
    this->initElements();
    *this = Ref::DpDemo_StringArray(Fw::String(""));
  }

  DpDemo_StringArray ::
    DpDemo_StringArray(const ElementType (&a)[SIZE]) :
      Serializable()
  {
    this->initElements();
    *this = a;
  }

  DpDemo_StringArray ::
    DpDemo_StringArray(const Fw::StringBase& e) :
      Serializable()
  {
    this->initElements();
    for (FwSizeType index = 0; index < SIZE; index++) {
      this->elements[index] = e;
    }
  }

  DpDemo_StringArray ::
    DpDemo_StringArray(const std::initializer_list<Fw::String>& il) :
      Serializable()
  {
    this->initElements();
    *this = il;
  }

  DpDemo_StringArray ::
    DpDemo_StringArray(const DpDemo_StringArray& obj) :
      Serializable()
  {
    this->initElements();
    *this = obj;
  }

  // ----------------------------------------------------------------------
  // Operators
  // ----------------------------------------------------------------------

  DpDemo_StringArray::ElementType& DpDemo_StringArray ::
    operator[](const FwSizeType i)
  {
    FW_ASSERT(i < SIZE, static_cast<FwAssertArgType>(i), static_cast<FwAssertArgType>(SIZE));
    return this->elements[i];
  }

  const DpDemo_StringArray::ElementType& DpDemo_StringArray ::
    operator[](const FwSizeType i) const
  {
    FW_ASSERT(i < SIZE, static_cast<FwAssertArgType>(i), static_cast<FwAssertArgType>(SIZE));
    return this->elements[i];
  }

  DpDemo_StringArray& DpDemo_StringArray ::
    operator=(const DpDemo_StringArray& obj)
  {
    if (this != &obj) {
      for (FwSizeType index = 0; index < SIZE; index++) {
        this->elements[index] = obj.elements[index];
      }
    }
    return *this;
  }

  DpDemo_StringArray& DpDemo_StringArray ::
    operator=(const ElementType (&a)[SIZE])
  {
    for (FwSizeType index = 0; index < SIZE; index++) {
      this->elements[index] = a[index];
    }
    return *this;
  }

  DpDemo_StringArray& DpDemo_StringArray ::
    operator=(const std::initializer_list<Fw::String>& il)
  {
    // Since we are required to use C++11, this has to be a runtime check
    // In C++14, it can be a static check
    FW_ASSERT(il.size() == SIZE, static_cast<FwAssertArgType>(il.size()), static_cast<FwAssertArgType>(SIZE));
    FwSizeType i = 0;
    for (const auto& e : il) {
      FW_ASSERT(i < SIZE, static_cast<FwAssertArgType>(i), static_cast<FwAssertArgType>(SIZE));
      this->elements[i] = e;
      i++;
    }
    return *this;
  }

  DpDemo_StringArray& DpDemo_StringArray ::
    operator=(const ElementType& e)
  {
    for (FwSizeType index = 0; index < SIZE; index++) {
      this->elements[index] = e;
    }
    return *this;
  }

  bool DpDemo_StringArray ::
    operator==(const DpDemo_StringArray& obj) const
  {
    for (FwSizeType index = 0; index < SIZE; index++) {
      if (!((*this)[index] == obj[index])) {
        return false;
      }
    }
    return true;
  }

  bool DpDemo_StringArray ::
    operator!=(const DpDemo_StringArray& obj) const
  {
    return !(*this == obj);
  }

#ifdef BUILD_UT

  std::ostream& operator<<(std::ostream& os, const DpDemo_StringArray& obj) {
    Fw::String s;
    obj.toString(s);
    os << s;
    return os;
  }

#endif

  // ----------------------------------------------------------------------
  // Public member functions
  // ----------------------------------------------------------------------

  Fw::SerializeStatus DpDemo_StringArray ::
    serializeTo(Fw::SerializeBufferBase& buffer) const
  {
    Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
    for (FwSizeType index = 0; index < SIZE; index++) {
      status = buffer.serializeFrom((*this)[index]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    return status;
  }

  Fw::SerializeStatus DpDemo_StringArray ::
    deserializeFrom(Fw::SerializeBufferBase& buffer)
  {
    Fw::SerializeStatus status = Fw::FW_SERIALIZE_OK;
    for (FwSizeType index = 0; index < SIZE; index++) {
      status = buffer.deserializeTo((*this)[index]);
      if (status != Fw::FW_SERIALIZE_OK) {
        return status;
      }
    }
    return status;
  }

  FwSizeType DpDemo_StringArray ::
    serializedSize() const
  {
    FwSizeType size = 0;
    for (FwSizeType index = 0; index < SIZE; index++) {
      size += this->elements[index].serializedSize();
    }
    return size;
  }

#if FW_SERIALIZABLE_TO_STRING

  void DpDemo_StringArray ::
    toString(Fw::StringBase& sb) const
  {
    // Clear the output string
    sb = "";

    // Array prefix
    if (sb.length() + 2 <= sb.maxLength()) {
      sb += "[ ";
    } else {
      return;
    }

    for (FwSizeType index = 0; index < SIZE; index++) {
      Fw::String tmp;
      tmp = this->elements[index];

      FwSizeType size = tmp.length() + (index > 0 ? 2 : 0);
      if ((size + sb.length()) <= sb.maxLength()) {
        if (index > 0) {
          sb += ", ";
        }
        sb += tmp;
      } else {
        break;
      }
    }

    // Array suffix
    if (sb.length() + 2 <= sb.maxLength()) {
      sb += " ]";
    }
  }

#endif

  // ----------------------------------------------------------------------
  // Private member functions
  // ----------------------------------------------------------------------

  void DpDemo_StringArray ::
    initElements()
  {
    for (FwSizeType index = 0; index < SIZE; index++) {
      this->elements[index].setBuffer(&this->buffers[index][0], sizeof this->buffers[index]);
    }
  }

}
